{"version":3,"sources":["service-worker.js"],"names":["OFFLINE_VERSION","CACHE_NAME","OFFLINE_URL","self","addEventListener","event"],"mappings":";AAIA,MAAMA,EAAkB,EAClBC,EAAa,UAEbC,EAAc,eAEpBC,KAAKC,iBAAiB,UAAWC,OAcjCF,KAAKC,iBAAiB,WAAYC,OAclCF,KAAKC,iBAAiB,QAASC","file":"service-worker.js","sourceRoot":"../src","sourcesContent":["/* eslint-disable no-undef */\n\n// Incrementing OFFLINE_VERSION will kick off the install event and force\n// previously cached resources to be updated from the network.\nconst OFFLINE_VERSION = 1;\nconst CACHE_NAME = 'offline';\n// Customize this with a different URL if needed.\nconst OFFLINE_URL = 'offline.html';\n\nself.addEventListener('install', event => {\n  // event.waitUntil(\n  //   (async () => {\n  //     const cache = await caches.open(CACHE_NAME);\n  //     // Setting {cache: 'reload'} in the new request will ensure that the\n  //     // response isn't fulfilled from the HTTP cache; i.e., it will be from\n  //     // the network.\n  //     await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));\n  //   })(),\n  // );\n  // // Force the waiting service worker to become the active service worker.\n  // self.skipWaiting();\n});\n\nself.addEventListener('activate', event => {\n  // event.waitUntil(\n  //   (async () => {\n  //     // Enable navigation preload if it's supported.\n  //     // See https://developers.google.com/web/updates/2017/02/navigation-preload\n  //     if ('navigationPreload' in self.registration) {\n  //       await self.registration.navigationPreload.enable();\n  //     }\n  //   })(),\n  // );\n  // // Tell the active service worker to take control of the page immediately.\n  // self.clients.claim();\n});\n\nself.addEventListener('fetch', event => {\n  // // We only want to call event.respondWith() if this is a navigation request\n  // // for an HTML page.\n  // if (event.request.mode === 'navigate') {\n  //   event.respondWith(\n  //     (async () => {\n  //       try {\n  //         // First, try to use the navigation preload response if it's supported.\n  //         const preloadResponse = await event.preloadResponse;\n  //         if (preloadResponse) {\n  //           return preloadResponse;\n  //         }\n  //         // Always try the network first.\n  //         const networkResponse = await fetch(event.request);\n  //         return networkResponse;\n  //       } catch (error) {\n  //         // catch is only triggered if an exception is thrown, which is likely\n  //         // due to a network error.\n  //         // If fetch() returns a valid HTTP response with a response code in\n  //         // the 4xx or 5xx range, the catch() will NOT be called.\n  //         console.log('Fetch failed; returning offline page instead.', error);\n  //         const cache = await caches.open(CACHE_NAME);\n  //         const cachedResponse = await cache.match(OFFLINE_URL);\n  //         return cachedResponse;\n  //       }\n  //     })(),\n  //   );\n  // }\n  // If our if() condition is false, then this fetch handler won't intercept the\n  // request. If there are any other fetch handlers registered, they will get a\n  // chance to call event.respondWith(). If no fetch handlers call\n  // event.respondWith(), the request will be handled by the browser as if there\n  // were no service worker involvement.\n});\n"]}